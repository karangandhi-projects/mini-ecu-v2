/**
 * @file    can_if.c
 * @brief   CAN interface abstraction for the Mini ECU project.
 *
 * Responsibilities:
 *   - Configure and start CAN1 (loopback, filter, interrupts).
 *   - Provide a telemetry TX API (VehicleState_t â†’ CAN frame).
 *   - Buffer received frames in an RTOS message queue.
 *   - Provide optional logging via Log_* when enabled from CLI.
 */

#include "can_if.h"
#include "log.h"
#include <string.h>
#include <stdio.h>

/* External handles generated by CubeMX (defined in main.c) */
extern CAN_HandleTypeDef  hcan1;

/* -------------------------------------------------------------------------- */
/* Local state                                                                */
/* -------------------------------------------------------------------------- */

/** RX queue used by CanRxTask to receive CAN frames from ISR context. */
static osMessageQueueId_t s_canRxQueue = NULL;

/** Flag controlled by CLI to turn CAN RX logging on/off. */
static uint8_t s_canLoggingEnabled = 0U;

/* -------------------------------------------------------------------------- */
/* Public API                                                                 */
/* -------------------------------------------------------------------------- */

HAL_StatusTypeDef CAN_IF_Init(void)
{
    HAL_StatusTypeDef status = HAL_OK;

    /* --- 1. Configure filter: accept all IDs into FIFO0. ----------------- */
    CAN_FilterTypeDef filterCfg;
    memset(&filterCfg, 0, sizeof(filterCfg));

    filterCfg.FilterBank           = 0;
    filterCfg.FilterMode           = CAN_FILTERMODE_IDMASK;
    filterCfg.FilterScale          = CAN_FILTERSCALE_32BIT;
    filterCfg.FilterIdHigh         = 0x0000;
    filterCfg.FilterIdLow          = 0x0000;
    filterCfg.FilterMaskIdHigh     = 0x0000;
    filterCfg.FilterMaskIdLow      = 0x0000;
    filterCfg.FilterFIFOAssignment = CAN_FILTER_FIFO0;
    filterCfg.FilterActivation     = ENABLE;
    filterCfg.SlaveStartFilterBank = 14;

    status = HAL_CAN_ConfigFilter(&hcan1, &filterCfg);
    if (status != HAL_OK)
    {
        LOG_ERROR("CAN", "HAL_CAN_ConfigFilter failed, status=%ld err=0x%08lX",
                  (long)status, (unsigned long)hcan1.ErrorCode);
        return status;
    }

    /* --- 2. Start CAN peripheral. ---------------------------------------- */
    status = HAL_CAN_Start(&hcan1);
    if (status != HAL_OK)
    {
        LOG_ERROR("CAN", "HAL_CAN_Start failed, status=%ld err=0x%08lX",
                  (long)status, (unsigned long)hcan1.ErrorCode);
        return status;
    }

    /* --- 3. Enable RX + error notifications. ----------------------------- */
    uint32_t notifFlags =
        CAN_IT_RX_FIFO0_MSG_PENDING |
        CAN_IT_BUSOFF               |
        CAN_IT_ERROR                |
        CAN_IT_LAST_ERROR_CODE      |
        CAN_IT_ERROR_WARNING;

    status = HAL_CAN_ActivateNotification(&hcan1, notifFlags);
    if (status != HAL_OK)
    {
        LOG_ERROR("CAN", "HAL_CAN_ActivateNotification failed, status=%ld err=0x%08lX",
                  (long)status, (unsigned long)hcan1.ErrorCode);
        return status;
    }

    /* --- 4. Create RX message queue. ------------------------------------- */
    const osMessageQueueAttr_t queueAttr =
    {
        .name = "CanRxQueue"
    };

    s_canRxQueue = osMessageQueueNew(8U, sizeof(CAN_IF_Msg_t), &queueAttr);
    if (s_canRxQueue == NULL)
    {
        LOG_ERROR("CAN", "Failed to create CAN RX queue");
        return HAL_ERROR;
    }

    LOG_INFO("CAN", "CAN_IF initialized successfully");
    return HAL_OK;
}

void CAN_IF_SendTelemetry(const VehicleState_t *vs)
{
    if (vs == NULL)
        return;

    uint16_t speed_0p1 = (uint16_t)(vs->speed_kph * 10.0f);
    uint16_t rpm       = vs->engine_rpm;
    int16_t  temp_0p1  = (int16_t)(vs->coolant_temp_c * 10.0f);

    CAN_TxHeaderTypeDef txHeader;
    uint8_t data[8] = {0};
    uint32_t mailbox = 0;

    memset(&txHeader, 0, sizeof(txHeader));

    txHeader.StdId = 0x100U;
    txHeader.IDE   = CAN_ID_STD;
    txHeader.RTR   = CAN_RTR_DATA;
    txHeader.DLC   = 6U;

    data[0] = (uint8_t)(speed_0p1 & 0xFFU);
    data[1] = (uint8_t)((speed_0p1 >> 8) & 0xFFU);
    data[2] = (uint8_t)(rpm & 0xFFU);
    data[3] = (uint8_t)((rpm >> 8) & 0xFFU);
    data[4] = (uint8_t)(temp_0p1 & 0xFFU);
    data[5] = (uint8_t)((temp_0p1 >> 8) & 0xFFU);

    HAL_StatusTypeDef status = HAL_CAN_AddTxMessage(&hcan1, &txHeader, data, &mailbox);
    if (status != HAL_OK)
    {
        LOG_WARN("CAN",
                 "Telemetry TX failed (status=%ld, err=0x%08lX) "
                 "speed=%.1f rpm=%u temp=%.1f",
                 (long)status,
                 (unsigned long)hcan1.ErrorCode,
                 vs->speed_kph,
                 (unsigned)vs->engine_rpm,
                 vs->coolant_temp_c);
    }
}

void CAN_IF_SetLogging(uint8_t enable)
{
    s_canLoggingEnabled = (enable != 0U) ? 1U : 0U;
    LOG_INFO("CAN", "RX logging %s", s_canLoggingEnabled ? "ENABLED" : "DISABLED");
}

osMessageQueueId_t CAN_IF_GetRxQueueHandle(void)
{
    return s_canRxQueue;
}

void CAN_IF_ProcessRxMsg(const CAN_IF_Msg_t *msg)
{
    if ((msg == NULL) || (s_canLoggingEnabled == 0U))
        return;

    char payload[3 * 8 + 1]; /* "xx " * 8 + '\0' */
    size_t pos = 0U;

    for (uint8_t i = 0U; i < msg->DLC && i < 8U; ++i)
    {
        if (pos + 3U >= sizeof(payload))
            break;
        int n = snprintf(&payload[pos], sizeof(payload) - pos, "%02X ", msg->Data[i]);
        if (n <= 0)
            break;
        pos += (size_t)n;
    }
    if (pos > 0U && payload[pos - 1U] == ' ')
        payload[pos - 1U] = '\0';
    else
        payload[pos] = '\0';

    uint32_t id = (msg->IDE ? msg->ExtId : msg->StdId);

    LOG_INFO("CAN", "RX ID=0x%03lX DLC=%u Data=%s",
             (unsigned long)id,
             (unsigned)msg->DLC,
             payload);
}

/* -------------------------------------------------------------------------- */
/* HAL callbacks (ISR context)                                                */
/* -------------------------------------------------------------------------- */

void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan)
{
    if (hcan != &hcan1)
        return;

    CAN_RxHeaderTypeDef rxHeader;
    uint8_t             rxData[8];

    if (HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &rxHeader, rxData) != HAL_OK)
    {
        LOG_WARN("CAN", "HAL_CAN_GetRxMessage failed, err=0x%08lX",
                 (unsigned long)hcan1.ErrorCode);
        return;
    }

    if (s_canRxQueue == NULL)
        return;

    CAN_IF_Msg_t msg;
    memset(&msg, 0, sizeof(msg));

    msg.StdId = rxHeader.StdId;
    msg.ExtId = rxHeader.ExtId;
    msg.IDE   = (uint8_t)rxHeader.IDE;
    msg.RTR   = (uint8_t)rxHeader.RTR;
    msg.DLC   = rxHeader.DLC;

    uint8_t len = (rxHeader.DLC <= 8U) ? rxHeader.DLC : 8U;
    for (uint8_t i = 0; i < len; ++i)
    {
        msg.Data[i] = rxData[i];
    }

    (void)osMessageQueuePut(s_canRxQueue, &msg, 0U, 0U);
}

void HAL_CAN_ErrorCallback(CAN_HandleTypeDef *hcan)
{
    if (hcan != &hcan1)
        return;

    LOG_WARN("CAN", "CAN error callback fired, err=0x%08lX",
             (unsigned long)hcan1.ErrorCode);
}

/* TX mailbox callbacks kept as no-ops for completeness. */

void HAL_CAN_TxMailbox0CompleteCallback(CAN_HandleTypeDef *hcan)
{
    (void)hcan;
}

void HAL_CAN_TxMailbox1CompleteCallback(CAN_HandleTypeDef *hcan)
{
    (void)hcan;
}

void HAL_CAN_TxMailbox2CompleteCallback(CAN_HandleTypeDef *hcan)
{
    (void)hcan;
}
